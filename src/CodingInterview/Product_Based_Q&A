# Complete Interview Q&A Guide - Product Based Companies

### 1. OOPs Concepts in Detail

**Four Pillars of OOP:**

- **Encapsulation**: Bundling data and methods together, hiding internal details using access modifiers (private, public, protected)
- **Inheritance**: Mechanism where a class acquires properties of another class (IS-A relationship)
- **Polymorphism**: Ability to take multiple forms (Method Overloading - compile time, Method Overriding - runtime)
- **Abstraction**: Hiding implementation details and showing only essential features

### 2. Abstraction vs Encapsulation

| Abstraction | Encapsulation |
|-------------|---------------|
| Hides complexity, shows only essential features | Hides data using access modifiers |
| Achieved using abstract classes and interfaces | Achieved using private variables with getters/setters |
| Design level concept | Implementation level concept |
| Focus: What to show | Focus: How to protect |

### 3. How HashMap Works Internally

- HashMap stores data in key-value pairs using an array of nodes (buckets)
- **Hashing**: Key's hashCode() determines the bucket index
- **Collision Handling**: Uses linked list (Java 7) or balanced tree (Java 8+) when multiple keys hash to same bucket
- **Load Factor**: Default 0.75 - when 75% full, capacity doubles (rehashing occurs)
- **Time Complexity**: O(1) average for get/put operations

```java
// Internal structure
Entry<K,V>[] table; // Array of nodes
static class Entry<K,V> {
    K key;
    V value;
    int hash;
    Entry<K,V> next; // For collision handling
}
```

### 4. Immutable Class - What and Why?

**What**: A class whose state cannot be changed after creation (String, Integer, etc.)

**Why**: Thread-safety, security, caching (good for HashMap keys), no side effects

**How to create:**
- Make class final
- Make all fields private and final
- No setter methods
- Initialize all fields via constructor
- Return deep copies for mutable objects

### 5. Exception Handling Hierarchy

```
Throwable
â”œâ”€â”€ Error (OutOfMemoryError, StackOverflowError)
â””â”€â”€ Exception
    â”œâ”€â”€ IOException
    â”œâ”€â”€ SQLException
    â”œâ”€â”€ RuntimeException (Unchecked)
    â”‚   â”œâ”€â”€ NullPointerException
    â”‚   â”œâ”€â”€ ArrayIndexOutOfBoundsException
    â”‚   â””â”€â”€ ArithmeticException
```

### 6. Checked vs Unchecked Exceptions

| Checked Exceptions | Unchecked Exceptions |
|-------------------|---------------------|
| Checked at compile time | Checked at runtime |
| Must handle with try-catch or throws | Not mandatory to handle |
| Examples: IOException, SQLException | Examples: NullPointerException, ArithmeticException |
| Extend Exception class | Extend RuntimeException class |

### 7. JVM, JRE, JDK Differences

- **JDK (Java Development Kit)**: Complete development package (JRE + development tools like compiler, debugger)
- **JRE (Java Runtime Environment)**: Runtime environment to execute Java programs (JVM + libraries)
- **JVM (Java Virtual Machine)**: Executes bytecode, platform dependent, provides runtime environment

**Relationship**: JDK âŠƒ JRE âŠƒ JVM

### 8. Garbage Collection

- **Purpose**: Automatically frees memory by destroying unused objects
- **Process**:
  - Mark: Identifies unreferenced objects
  - Sweep: Removes marked objects
  - Compact: Reorganizes memory
- **When**: When heap memory is full or System.gc() is called (not guaranteed)
- **Types**: Serial, Parallel, CMS, G1GC
- **Generational GC**: Young Generation (Eden, S0, S1) â†’ Old Generation

### 9. String vs StringBuilder vs StringBuffer

| Feature | String | StringBuilder | StringBuffer |
|---------|--------|--------------|--------------|
| Mutability | Immutable | Mutable | Mutable |
| Thread-safe | Yes | No | Yes (synchronized) |
| Performance | Slow (creates new object) | Fast | Slower than StringBuilder |
| Use case | Small operations | Single-threaded string manipulation | Multi-threaded string manipulation |

### 10. Singleton Class

A class that allows only one instance to be created.

```java
public class Singleton {
    private static Singleton instance;

    private Singleton() {} // Private constructor

    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

**Use cases**: Database connections, logging, configuration managers

---

## Selenium Interview Questions

### 1. Different Locators and When to Use

| Locator | Syntax | When to Use |
|---------|--------|-------------|
| ID | `driver.findElement(By.id("username"))` | Most reliable, fastest - use when available |
| Name | `driver.findElement(By.name("email"))` | Good for form elements |
| ClassName | `driver.findElement(By.className("btn"))` | For elements with unique class |
| TagName | `driver.findElement(By.tagName("input"))` | When multiple similar elements exist |
| LinkText | `driver.findElement(By.linkText("Click Here"))` | For exact link text |
| PartialLinkText | `driver.findElement(By.partialLinkText("Click"))` | For partial link text match |
| CSS Selector | `driver.findElement(By.cssSelector("#id .class"))` | Fast, flexible - good alternative |
| XPath | `driver.findElement(By.xpath("//div[@id='test']"))` | Most powerful, traverse anywhere |

**Preference**: ID > Name > CSS > XPath

### 2. Implicit Wait vs Explicit Wait

| Implicit Wait | Explicit Wait |
|--------------|---------------|
| Global wait for all elements | Wait for specific condition |
| Set once, applies to all findElement() | Applied to specific elements |
| `driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS)` | `WebDriverWait wait = new WebDriverWait(driver, 10); wait.until(ExpectedConditions.visibilityOf(element))` |
| Less flexible | More flexible, multiple conditions |
| Not recommended with Explicit wait | Recommended approach |

### 3. Page Object Model (POM) - Advantages

- **Separation of Concerns**: Test logic separate from page elements
- **Reusability**: Page classes can be reused across tests
- **Maintainability**: Changes in UI need updates only in page classes
- **Readability**: Tests become more readable
- **Reduces Code Duplication**: Common actions centralized

### 4. TestNG Annotations

```java
@BeforeSuite â†’ @BeforeTest â†’ @BeforeClass â†’ @BeforeMethod â†’ @Test â†’ @AfterMethod â†’ @AfterClass â†’ @AfterTest â†’ @AfterSuite
```

- `@Test`: Marks a method as test case
- `@BeforeMethod/@AfterMethod`: Runs before/after each test method
- `@BeforeClass/@AfterClass`: Runs once before/after all test methods in class
- `@BeforeTest/@AfterTest`: Runs before/after <test> tag in XML
- `@BeforeSuite/@AfterSuite`: Runs before/after entire suite

### 5. Handle Alerts, Windows, Frames

**Alerts:**
```java
Alert alert = driver.switchTo().alert();
alert.accept(); // OK
alert.dismiss(); // Cancel
alert.getText(); // Get text
alert.sendKeys("text"); // Enter text
```

**Windows:**
```java
String mainWindow = driver.getWindowHandle();
Set<String> allWindows = driver.getWindowHandles();
for(String window : allWindows) {
    driver.switchTo().window(window);
}
```

**Frames:**
```java
driver.switchTo().frame("frameName"); // By name
driver.switchTo().frame(0); // By index
driver.switchTo().frame(webElement); // By WebElement
driver.switchTo().defaultContent(); // Back to main page
```

### 6. Soft Assert vs Hard Assert

| Hard Assert | Soft Assert |
|------------|-------------|
| Stops execution on failure | Continues execution on failure |
| `Assert.assertEquals(actual, expected)` | `SoftAssert sa = new SoftAssert(); sa.assertEquals(actual, expected); sa.assertAll()` |
| Default behavior | Need to call assertAll() at end |
| Use for critical validations | Use for multiple validations |

### 7. Cross-Browser Testing

Running tests on different browsers to ensure compatibility.

```java
// Using WebDriverManager
WebDriverManager.chromedriver().setup();
WebDriver driver = new ChromeDriver();

WebDriverManager.firefoxdriver().setup();
WebDriver driver = new FirefoxDriver();
```

**Approaches**: TestNG XML with parameters, TestNG parallel execution, Selenium Grid

### 8. Handle Dynamic Web Elements

- Use Explicit Waits with Expected Conditions
- Use dynamic XPath/CSS with contains(), starts-with()
- `//div[contains(@id, 'dynamic')]`
- `//button[starts-with(@class, 'btn')]`
- Handle StaleElementReferenceException by re-locating element

### 9. driver.close() vs driver.quit()

| close() | quit() |
|---------|--------|
| Closes current browser window | Closes all browser windows |
| Doesn't terminate WebDriver session | Terminates WebDriver session completely |
| Can switch to other windows after | Cannot perform any action after |
| Use when handling multiple windows | Use at end of test execution |

---

## Cucumber Interview Questions

### 1. What is BDD?

**Behavior Driven Development**: Software development approach where tests are written in plain English to describe application behavior from user's perspective.

**Benefits**: Improves collaboration between technical and non-technical team members, living documentation, focus on business value

### 2. Gherkin Syntax Basics

```gherkin
Feature: Login Functionality
  As a user
  I want to login to application
  So that I can access my account

  Scenario: Successful login with valid credentials
    Given user is on login page
    When user enters valid username and password
    And clicks on login button
    Then user should be redirected to dashboard
```

**Keywords**: Feature, Scenario, Given, When, Then, And, But, Background, Scenario Outline, Examples

### 3. Step Definitions and Hooks

**Step Definitions**: Java methods that implement Gherkin steps

```java
@Given("user is on login page")
public void userIsOnLoginPage() {
    driver.get("https://example.com/login");
}
```

**Hooks**: Special methods that run before/after scenarios

```java
@Before
public void setUp() {
    // Runs before each scenario
}

@After
public void tearDown() {
    // Runs after each scenario
}
```

### 4. DataTable vs Examples

**DataTable**: Pass data within a single step
```gherkin
Given user has following details
  | name | email |
  | John | john@test.com |
```

**Examples (Scenario Outline)**: Run same scenario with multiple data sets
```gherkin
Scenario Outline: Login with multiple users
  When user logs in with "<username>" and "<password>"

  Examples:
    | username | password |
    | user1 | pass1 |
    | user2 | pass2 |
```

### 5. Background Keyword

Common steps that run before each scenario in a feature file.

```gherkin
Background:
  Given application is running
  And database is connected

Scenario: Test 1
  When...

Scenario: Test 2
  When...
```

### 6. Cucumber Integration with Selenium

```java
// Runner Class
@RunWith(Cucumber.class)
@CucumberOptions(
    features = "src/test/resources/features",
    glue = "stepDefinitions",
    plugin = {"pretty", "html:target/cucumber-reports"}
)
public class TestRunner { }

// Step Definition
public class LoginSteps {
    WebDriver driver = new ChromeDriver();

    @Given("user is on login page")
    public void navigateToLogin() {
        driver.get("https://example.com");
    }
}
```

### 7. Tags in Cucumber

Organize and filter scenarios for execution.

```gherkin
@smoke @regression
Scenario: Login test
  Given...

@sanity
Scenario: Dashboard test
  Given...
```

**Runner:**
```java
@CucumberOptions(
    tags = "@smoke and @regression"
)
```

### 8. Runner Class Structure

```java
@RunWith(Cucumber.class)
@CucumberOptions(
    features = "src/test/resources/features",
    glue = {"stepDefinitions", "hooks"},
    plugin = {"pretty", "html:target/reports", "json:target/cucumber.json"},
    tags = "@smoke",
    monochrome = true,
    dryRun = false
)
public class TestRunner { }
```

---

## TestNG Interview Questions

### 1. Why Use TestNG?

- Better annotations than JUnit
- Parallel test execution
- Grouping of test cases
- Data-driven testing with DataProvider
- Detailed HTML reports
- Dependency testing (dependsOnMethods)
- Test prioritization
- Listeners for custom actions

### 2. TestNG XML Suite Structure

```xml
<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd">
<suite name="Test Suite" parallel="tests" thread-count="2">
    <test name="Regression Tests">
        <classes>
            <class name="tests.LoginTest"/>
            <class name="tests.DashboardTest"/>
        </classes>
    </test>
    <test name="Smoke Tests">
        <groups>
            <run>
                <include name="smoke"/>
            </run>
        </groups>
        <packages>
            <package name="tests.*"/>
        </packages>
    </test>
</suite>
```

### 3. Priority and dependsOnMethods

**Priority**: Controls execution order (default: 0, lower executes first)
```java
@Test(priority = 1)
public void login() { }

@Test(priority = 2)
public void dashboard() { }
```

**dependsOnMethods**: Creates test dependencies
```java
@Test
public void login() { }

@Test(dependsOnMethods = "login")
public void verifyDashboard() { }
```

### 4. Groups in TestNG

```java
@Test(groups = {"smoke", "regression"})
public void test1() { }

@Test(groups = {"regression"})
public void test2() { }
```

**XML Configuration:**
```xml
<groups>
    <run>
        <include name="smoke"/>
        <exclude name="regression"/>
    </run>
</groups>
```

### 5. Parallel Execution

```xml
<suite name="Suite" parallel="methods" thread-count="3">
    <!-- parallel="tests" / "classes" / "methods" -->
</suite>
```

**Thread-safe WebDriver:**
```java
ThreadLocal<WebDriver> driver = new ThreadLocal<>();
driver.set(new ChromeDriver());
driver.get().findElement(...);
```

### 6. DataProvider - Use Cases

Run same test with multiple data sets.

```java
@DataProvider(name = "loginData")
public Object[][] getData() {
    return new Object[][] {
        {"user1", "pass1"},
        {"user2", "pass2"}
    };
}

@Test(dataProvider = "loginData")
public void loginTest(String username, String password) {
    // Test logic
}
```

### 7. Listener Types in TestNG

- **ITestListener**: Test execution events (onTestStart, onTestSuccess, onTestFailure)
- **ISuiteListener**: Suite level events
- **IInvokedMethodListener**: Before/after method invocation
- **IReporter**: Custom reporting

```java
public class TestListener implements ITestListener {
    public void onTestFailure(ITestResult result) {
        // Take screenshot
    }
}

// Usage
@Listeners(TestListener.class)
public class TestClass { }
```

---

## Rest Assured / API Testing

### 1. API Types

**REST (Representational State Transfer)**:
- Uses HTTP methods (GET, POST, PUT, DELETE)
- Stateless, lightweight
- Uses JSON/XML
- Resource-based URLs

**SOAP (Simple Object Access Protocol)**:
- XML-based protocol
- More structured, has standards
- Uses WSDL for service description
- Built-in security (WS-Security)

### 2. HTTP Status Codes

| Code Range | Meaning | Examples |
|------------|---------|----------|
| 1xx | Informational | 100 Continue |
| 2xx | Success | 200 OK, 201 Created, 204 No Content |
| 3xx | Redirection | 301 Moved Permanently, 302 Found |
| 4xx | Client Error | 400 Bad Request, 401 Unauthorized, 404 Not Found |
| 5xx | Server Error | 500 Internal Server Error, 503 Service Unavailable |

### 3. What is JSON?

**JavaScript Object Notation**: Lightweight data interchange format, human-readable, language-independent.

```json
{
  "name": "John",
  "age": 30,
  "address": {
    "city": "New York"
  },
  "hobbies": ["reading", "coding"]
}
```

### 4. HTTP Methods

| Method | Purpose | Idempotent | Safe |
|--------|---------|-----------|------|
| GET | Retrieve data | Yes | Yes |
| POST | Create resource | No | No |
| PUT | Update/Replace resource | Yes | No |
| PATCH | Partial update | No | No |
| DELETE | Delete resource | Yes | No |

### 5. Idempotent API

Making same request multiple times produces same result.

- **Idempotent**: GET, PUT, DELETE (calling 10 times = calling once)
- **Not Idempotent**: POST (creates new resource each time)

### 6. Validate Response Body

```java
given()
    .baseUri("https://api.example.com")
.when()
    .get("/users/1")
.then()
    .statusCode(200)
    .body("name", equalTo("John"))
    .body("age", greaterThan(18))
    .body("address.city", equalTo("NYC"));
```

### 7. Authentication Types

**Basic Auth**: Username and password encoded in Base64
```java
given().auth().basic("username", "password")
```

**Bearer Token**: Token-based authentication
```java
given().header("Authorization", "Bearer " + token)
```

**OAuth 2.0**: Token obtained through authorization flow
```java
given().auth().oauth2(accessToken)
```

### 8. Headers vs Cookies

**Headers**: Metadata sent with request/response (Content-Type, Authorization)
```java
given().header("Content-Type", "application/json")
```

**Cookies**: Small data stored on client, sent with requests
```java
given().cookie("sessionId", "abc123")
```

### 9. Serialization / Deserialization

**Serialization**: Java Object â†’ JSON
```java
User user = new User("John", 30);
given().body(user) // Automatic serialization
```

**Deserialization**: JSON â†’ Java Object
```java
User user = given().get("/user").as(User.class);
```

---

## Manual + QA Concepts

### 1. SDLC vs STLC

**SDLC (Software Development Life Cycle)**: Complete software development process
- Phases: Requirement â†’ Design â†’ Development â†’ Testing â†’ Deployment â†’ Maintenance

**STLC (Software Testing Life Cycle)**: Testing-specific phases
- Phases: Requirement Analysis â†’ Test Planning â†’ Test Design â†’ Test Environment Setup â†’ Test Execution â†’ Test Closure

### 2. Agile Ceremonies

- **Sprint Planning**: Plan work for upcoming sprint
- **Daily Standup**: Daily 15-min sync (what done, what doing, blockers)
- **Sprint Review**: Demo completed work to stakeholders
- **Sprint Retrospective**: Team reflects on process improvements
- **Backlog Refinement**: Clarify and estimate upcoming stories

### 3. Bug Life Cycle

New â†’ Assigned â†’ Open â†’ Fixed â†’ Retest â†’ Verified â†’ Closed

**Other states**: Rejected, Deferred, Reopened, Duplicate

### 4. Severity vs Priority

| Severity | Priority |
|----------|----------|
| Impact of bug on system | Order of fixing |
| Technical perspective | Business perspective |
| High: System crash | High: Must fix immediately |
| Medium: Feature broken | Medium: Fix in current release |
| Low: UI issue | Low: Can defer to future |

**Example**: Typo on homepage - Low Severity, High Priority (visible to all users)

### 5. Test Case vs Test Scenario

**Test Scenario**: High-level functionality to test (What to test)
- "Verify login functionality"

**Test Case**: Detailed steps with expected results (How to test)
- ID: TC001
- Steps: 1. Open app 2. Enter username 3. Enter password 4. Click login
- Expected: User logged in successfully

### 6. Smoke vs Sanity Testing

| Smoke Testing | Sanity Testing |
|--------------|----------------|
| Basic functionality check | Specific functionality check after changes |
| Done on new build | Done after bug fixes |
| Wide and shallow | Narrow and deep |
| Documented | Usually undocumented |
| Scripted | Unscripted |

### 7. Functional vs Non-Functional Testing

**Functional**: What the system does (login, search, checkout)

**Non-Functional**: How the system performs
- Performance, Load, Stress, Security, Usability, Compatibility

### 8. Regression Testing

Re-testing entire application after changes to ensure existing functionality still works.

**When**: After bug fixes, new features, code changes
**Types**: Complete, Partial, Unit regression

### 9. How to Write Good Test Cases

- **Clear Title**: Descriptive and specific
- **Preconditions**: State required before test
- **Test Steps**: Numbered, detailed steps
- **Expected Result**: Clear expected outcome
- **Test Data**: Specify input data
- **Priority/Severity**: Mark importance
- **Traceable**: Link to requirements
- **Reusable**: Write for reusability
- **Maintainable**: Easy to update

### 10. Root Cause Analysis

Identifying underlying cause of a defect, not just symptoms.

**5 Whys Technique**:
- Bug: User cannot login
- Why? Password validation failing
- Why? Regex pattern incorrect
- Why? Requirements misunderstood
- Why? Lack of requirement review process
- Root Cause: No requirement review process

---

## Appium Interview Questions

### 1. Appium Architecture

```
Test Script (Java/Python)
    â†“
Appium Server (Node.js)
    â†“
WebDriver Protocol
    â†“
UIAutomator2 (Android) / XCUITest (iOS)
    â†“
Mobile Device/Emulator
```

### 2. Native vs Hybrid vs Web Apps

| Type | Description | Technology |
|------|-------------|------------|
| Native | Built for specific platform | Swift (iOS), Kotlin (Android) |
| Hybrid | Web app wrapped in native container | Cordova, Ionic |
| Web | Accessed via mobile browser | HTML5, responsive design |

### 3. DesiredCapabilities

Configuration settings to communicate with Appium server.

```java
DesiredCapabilities caps = new DesiredCapabilities();
caps.setCapability("platformName", "Android");
caps.setCapability("deviceName", "Pixel 4");
caps.setCapability("automationName", "UiAutomator2");
caps.setCapability("app", "/path/to/app.apk");
caps.setCapability("appPackage", "com.example.app");
caps.setCapability("appActivity", "com.example.MainActivity");
```

### 4. AppPackage & AppActivity

**AppPackage**: Unique identifier for Android app (com.example.app)

**AppActivity**: Entry point screen of app (com.example.MainActivity)

**Find them**:
```bash
# Using adb
adb shell dumpsys window | grep -E 'mCurrentFocus'
```

### 5. Setup Appium on macOS

```bash
# Install Node.js
brew install node

# Install Appium
npm install -g appium

# Install Appium Doctor
npm install -g appium-doctor

# Check setup
appium-doctor

# Install Android SDK, set ANDROID_HOME
export ANDROID_HOME=/path/to/android/sdk

# Start Appium
appium
```

### 6. Locators for Mobile Automation

- **ID**: `driver.findElement(By.id("com.example:id/username"))`
- **Accessibility ID**: `driver.findElement(MobileBy.AccessibilityId("loginButton"))`
- **XPath**: `driver.findElement(By.xpath("//android.widget.Button[@text='Login']"))`
- **Class Name**: `driver.findElement(By.className("android.widget.EditText"))`
- **Android UIAutomator**: `driver.findElement(MobileBy.AndroidUIAutomator("new UiSelector().text(\"Login\")"))`
- **iOS Predicate String**: `driver.findElement(MobileBy.iOSNsPredicateString("label == 'Login'"))`

### 7. Real Device vs Emulator

| Real Device | Emulator |
|------------|----------|
| Accurate performance testing | Faster to set up |
| Real user experience | Multiple configurations easily |
| Hardware features (GPS, camera) | Cost-effective |
| Requires physical connection | Limited hardware simulation |
| Slower test execution | Faster test execution |
| Better for production testing | Good for development testing |

---

## Tips for Interview Success

1. **Understand concepts, don't memorize**: Be ready to explain with examples
2. **Practice coding**: Be comfortable writing code on whiteboard/screen
3. **Project experience**: Relate answers to your actual projects
4. **Ask clarifying questions**: Shows analytical thinking
5. **Be honest**: Say "I don't know" if you don't, but show willingness to learn
6. **Prepare questions**: Have intelligent questions about company/role
7. **Mock interviews**: Practice with peers or mentors
8. **Stay updated**: Know latest trends in testing/automation

---

## Common Follow-up Questions to Prepare

- Can you explain with a real project example?
- What challenges did you face and how did you solve them?
- How would you handle [specific scenario]?
- What's your approach to debugging failed tests?
- How do you ensure test reliability and maintainability?

**Good luck with your interviews! ðŸŽ¯**